<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ClearCore Library: ClearCore Ethernet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ClearCore Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="SdkExamples.html"><span>SDK&#160;Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> Ethernet </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Overview </h1>
<p><a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> provides fully-featured Ethernet functionality at 10 Mbps and 100 Mbps with a 10Base-T/100Base-TX Ethernet port. The <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> package implements LwIP's TCP/IP protocol suite and <br />
 provides a user-friendly API for TCP and UDP capabilities.</p>
<h2>Wiring and Initialization </h2>
<ul>
<li>Connect the <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> to a router/switch using a standard ethernet RJ45 cable, or directly to another <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> or PC using an ethernet cross-over cable. Use the dedicated <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> ETHERNET <br />
 port.</li>
<li>Make sure the router/switch or connected device is on.</li>
<li>Verify that the Ethernet connector's LED turns on. This is a status indicator for link activity. The Ethernet LED can only indicate one of two states, off or blinking, to indicate the absence <br />
 or prescence of network activity, respectively.<ul>
<li>If the LED does not come on after connecting an RJ45 cable connected to the network the <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> won't be able to communicate on the network.</li>
</ul>
</li>
<li>Set up Ethernet functionality through the <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> <a class="el" href="class_clear_core_1_1_ethernet_manager.html" title="ClearCore Ethernet configuration manager. ">EthernetManager</a>.<ul>
<li>To configure with a static IP address, if manual configuration is required or DHCP is unavailable: <div class="fragment"><div class="line"><span class="comment">// Specify the desired network values:</span></div><div class="line"><span class="comment">// ClearCore IP address</span></div><div class="line">IpAddress ip = IpAddress(192, 168, 1, 8);</div><div class="line"><span class="comment">// Router/switch IP address</span></div><div class="line">IpAddress gateway = IpAddress(192, 168, 1, 1);</div><div class="line"><span class="comment">// Mask to separate network vs. host addresses (required for TCP)</span></div><div class="line">IpAddress netmask = IpAddress(255, 255, 255, 0);</div><div class="line"></div><div class="line"><span class="comment">// Set the network values through the EthernetManager.</span></div><div class="line"><a class="code" href="namespace_clear_core.html#ab9b9a29bc36dde08f25dd3f4a05c7a71">EthernetMgr</a>.<a class="code" href="class_clear_core_1_1_ethernet_manager.html#ac2ad04c16266f9de35d6f250d74ffb91">Setup</a>();</div><div class="line"><a class="code" href="namespace_clear_core.html#ab9b9a29bc36dde08f25dd3f4a05c7a71">EthernetMgr</a>.<a class="code" href="class_clear_core_1_1_ethernet_manager.html#a47d7bd98cf202ef7c7fab10b80fa5d63">LocalIp</a>(ip);</div><div class="line"><a class="code" href="namespace_clear_core.html#ab9b9a29bc36dde08f25dd3f4a05c7a71">EthernetMgr</a>.<a class="code" href="class_clear_core_1_1_ethernet_manager.html#a4c41e5666914d99526aefdcc6b6ca699">GatewayIp</a>(gateway);</div><div class="line"><a class="code" href="namespace_clear_core.html#ab9b9a29bc36dde08f25dd3f4a05c7a71">EthernetMgr</a>.<a class="code" href="class_clear_core_1_1_ethernet_manager.html#a007fa4e93e5edb7ee879266806ac7987">NetmaskIp</a>(netmask);</div></div><!-- fragment --></li>
<li>To configure with an IP address assigned via DHCP: <div class="fragment"><div class="line"><a class="code" href="namespace_clear_core.html#ab9b9a29bc36dde08f25dd3f4a05c7a71">EthernetMgr</a>.<a class="code" href="class_clear_core_1_1_ethernet_manager.html#ac2ad04c16266f9de35d6f250d74ffb91">Setup</a>();</div><div class="line"><span class="keywordtype">bool</span> dhcpSuccess = <a class="code" href="namespace_clear_core.html#ab9b9a29bc36dde08f25dd3f4a05c7a71">EthernetMgr</a>.<a class="code" href="class_clear_core_1_1_ethernet_manager.html#ac1d6d902e5dc391a556e054c6924e307">DhcpBegin</a>();</div><div class="line"><span class="keywordflow">if</span> (dhcpSuccess) {</div><div class="line">    <span class="comment">// DHCP successfully assigned an IP address.</span></div><div class="line">}</div></div><!-- fragment --></li>
</ul>
</li>
<li>To confirm that everything is working properly, once an IP address has been assigned, you should be able to communicate to the <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> using the Windows ping command from a PC on the same <br />
 network.<ul>
<li>Make sure that the sketch running on the <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> calls EthernetMgr.Refresh() in a timely manner in the loop() function so that incoming and outgoing packets will get processed. In <br />
 practical applications, this refreshing will be taken care of by the functions that send and receive packets.</li>
<li>Connect a PC to the router/switch that the <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> is connected to.</li>
<li>On that PC, open a Windows cmd shell, type "ping &lt;ClearCore_IP_address&gt;", and hit Enter. You should see four lines that begin with "Reply from &lt;ClearCore_IP_address&gt;: bytes=32", indicating <br />
 that the <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> is online.</li>
<li>If instead you see "Reply from &lt;ClearCore_IP_address&gt;: Destination host unreachable", or if the ping otherwise fails, make sure the router/switch is on, the correct IP address was supplied <br />
 to ping, and that the <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> is running a sketch that called EthernetMgr.Setup(), successfully configured an IP address, and calls EthernetMgr.Refresh() at a reasonable rate.</li>
</ul>
</li>
</ul>
<h2>Ethernet TCP </h2>
<p>The TCP functionality of the <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> provides a Client-Server interface, allowing the <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> to act as either a client or a server. TCP is connection-oriented and provides built-in error <br />
 checking, guaranteed packet delivery, and delivery of packets in order. TCP is best suited for an application where reliability is more valuable than speed.</p>
<h3>TCP Client </h3>
<p>From the Client-Server perspective, the client of a TCP connection is the device who initiates the connection.</p><ul>
<li>To initialize the <a class="el" href="namespace_clear_core.html" title="Namespace to encompass the ClearCore board API. ">ClearCore</a> as a client connecting to a remote server: <div class="fragment"><div class="line">EthernetTcpClient client;</div><div class="line">IpAddress serverIp = IpAddress(192, 168, 1, 78);</div><div class="line"><span class="comment">// Start a TCP connection with the server on port 8888.</span></div><div class="line"><span class="keywordflow">if</span> (client.Connect(serverIp, 8888)) {</div><div class="line">    <span class="comment">// Successfully connected to the server.</span></div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Ethernet functionality must be initialized before initializing TCP communications.</dd></dl>
</li>
<li>To communicate with the connected server:<ul>
<li>Incoming TCP packets from the server are automatically buffered within the client. To process received data, the client's buffer can be read-from directly at any time by calling <br />
 <a class="el" href="class_clear_core_1_1_ethernet_tcp_client.html#ad58c85ee1eb019cbd4b2db068f3adf44" title="Attempt to read the next available character. ">EthernetTcpClient::Read()</a>.</li>
<li>Outgoing TCP packets are automatically created and sent when using the <a class="el" href="class_clear_core_1_1_ethernet_tcp_client.html#a489bc2628654fccf352b4aa96f972b52" title="Send the buffer contents to the server. ">EthernetTcpClient::Send()</a> API. The TCP protocol of acknowledging received packets and resending lost packets is <br />
 handled automatically.</li>
</ul>
</li>
</ul>
<h3>TCP Server </h3>
<p>From the Client-Server perspective, the server of a TCP connection is the device that listens for and accepts incoming connection requests. The <a class="el" href="class_clear_core_1_1_ethernet_tcp_server.html" title="ClearCore TCP server class. ">EthernetTcpServer</a> interface provides two distinct options for managing connected clients. Choose one or the other, but do not mix usage of <a class="el" href="class_clear_core_1_1_ethernet_tcp_server.html#a95b9a2ca715e800a58dadef37820abfa" title="Return a reference to a client that has incoming data. ">EthernetTcpServer::Available()</a> and <a class="el" href="class_clear_core_1_1_ethernet_tcp_server.html#a4243197440ba1aecd4ca1cd6fe0318e7" title="Return a client with an active connection. ">EthernetTcpServer::Accept()</a>.</p>
<h3>Automatic Client Management (recommended)</h3>
<pre class="fragment">    - To obtain a reference to a connected client while leaving management of that client up to the server, use EthernetTcpServer::Available()
  - Each client reference is an EthernetTcpClient object. 
    - Incoming TCP packets from an individual client are automatically buffered within the client. To process received data, the client's buffer can be read-from directly at any time by
</pre><p> calling <a class="el" href="class_clear_core_1_1_ethernet_tcp_client.html#ad58c85ee1eb019cbd4b2db068f3adf44" title="Attempt to read the next available character. ">EthernetTcpClient::Read()</a>.</p><ul>
<li>Outgoing TCP packets to an individual client are automatically created and sent when using the <a class="el" href="class_clear_core_1_1_ethernet_tcp_client.html#a489bc2628654fccf352b4aa96f972b52" title="Send the buffer contents to the server. ">EthernetTcpClient::Send()</a> API. The TCP protocol of acknowledging received packets and resending lost packets is handled automatically.</li>
<li>Outgoing TCP packets may be sent through the server to all currently connected clients using <a class="el" href="class_clear_core_1_1_ethernet_tcp_server.html#a5c1c5a3dfdeacd10d69c843e3dd1435c" title="Send data to all clients managed by the server. ">EthernetTcpServer::Send()</a>. (applicable only when using the server’s automatic Client management).</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Initialize the ClearCore as a server listening for incoming client connections</span></div><div class="line">  EthernetTcpServer server = EthernetTcpServer(8888);</div><div class="line">  <span class="comment">// Start listening for TCP connections on port 8888.</span></div><div class="line">  server.Begin();</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Obtain a reference to a connected client with incoming data                              available.</span></div><div class="line">        EthernetTcpClient client = server.Available();</div><div class="line">        <span class="keywordflow">if</span> (client.Connected()) {</div><div class="line"><span class="comment">// The server has returned a connected client with incoming data available.</span></div><div class="line">           <span class="keywordflow">while</span> (client.BytesAvailable() &gt; 0) {</div><div class="line">    <span class="comment">// Send the data received from the client over a serial port.</span></div><div class="line">               <a class="code" href="namespace_clear_core.html#a748569765cfde0a971ddb9eebb89e327">ConnectorCOM0</a>.<a class="code" href="class_clear_core_1_1_i_serial.html#aa609f4a056cecb71d7ebe13fc74937fd">Send</a>(client.Read());</div><div class="line">           }</div><div class="line">        }</div></div><!-- fragment --><h3>Manual Client Management</h3>
<ul>
<li>To obtain a reference to a connected client and stop it from being managed by the server, use <a class="el" href="class_clear_core_1_1_ethernet_tcp_server.html#a4243197440ba1aecd4ca1cd6fe0318e7" title="Return a client with an active connection. ">EthernetTcpServer::Accept()</a>.<ul>
<li>Each client reference is an <a class="el" href="class_clear_core_1_1_ethernet_tcp_client.html" title="ClearCore TCP client class. ">EthernetTcpClient</a> object.<ul>
<li>Incoming TCP packets from an individual client are automatically buffered within the client. To process received data, the client's buffer can be read-from directly at any time by <br />
 calling <a class="el" href="class_clear_core_1_1_ethernet_tcp_client.html#ad58c85ee1eb019cbd4b2db068f3adf44" title="Attempt to read the next available character. ">EthernetTcpClient::Read()</a>.</li>
<li>Outgoing TCP packets to an individual client are automatically created and sent when using the <a class="el" href="class_clear_core_1_1_ethernet_tcp_client.html#a489bc2628654fccf352b4aa96f972b52" title="Send the buffer contents to the server. ">EthernetTcpClient::Send()</a> API. The TCP protocol of acknowledging received packets and <br />
 resending lost packets is handled automatically. <div class="fragment"><div class="line"><span class="comment">// Initialize the ClearCore as a server listening for incoming client connections</span></div><div class="line">  EthernetTcpServer server = EthernetTcpServer(8888);</div><div class="line">  <span class="comment">// Start listening for TCP connections on port 8888.</span></div><div class="line">  server.Begin();</div></div><!-- fragment --></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// The server will no longer keep track of connected clients returned by Accept().</span></div><div class="line">EthernetTcpClient clients[4];</div><div class="line">clients[0] = server.Accept();</div><div class="line"><span class="keywordflow">if</span> (clients[0].Connected()) {</div><div class="line">    <span class="comment">// Send a TCP packet to the client with a payload containing the string.</span></div><div class="line">    clients[0].Send(<span class="stringliteral">&quot;Hello World&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><h2>Ethernet UDP </h2>
<p>UDP communications are connectionless and do not provide error checking or guaranteed delivery. The <a class="el" href="class_clear_core_1_1_ethernet_udp.html" title="ClearCore UDP session class. ">EthernetUdp</a> interface manages a local UDP session and provides methods for sending and receiving <br />
 UDP datagrams. UDP is best suited for an application that performs its own error checking and appropriately handles packet loss or an application that requires efficiency and speed.</p>
<ul>
<li>UDP Initialization<ul>
<li>To initialize a local UDP session: <div class="fragment"><div class="line"><span class="comment">// Start a local UDP session on port 23.</span></div><div class="line">EthernetUdp Udp;</div><div class="line">Udp.Begin(23);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Ethernet functionality must be initialized before initializing UDP. </dd>
<dd>
An <a class="el" href="class_clear_core_1_1_ethernet_udp.html" title="ClearCore UDP session class. ">EthernetUdp</a> instance is bound to a local port upon initialization. Providing a local port number of 0 will bind to a random local port.</dd></dl>
</li>
</ul>
</li>
<li>UDP Communication<ul>
<li>To send a UDP datagram to a remote destination: <div class="fragment"><div class="line"><span class="comment">// Form a new packet addressed to a specified remote IP address and port.</span></div><div class="line">IpAddress remoteIp = IpAddress(192, 168, 1, 78);</div><div class="line">uint16_t remotePort = 8888;</div><div class="line"><span class="comment">// Set up to send a packet to a remote IP/port.</span></div><div class="line">Udp.Connect(remoteIp, remotePort);</div><div class="line"><span class="comment">// Write data into the payload of the outgoing packet.</span></div><div class="line">Udp.PacketWrite(<span class="stringliteral">&quot;Hello World.&quot;</span>);</div><div class="line"><span class="comment">// Send the packet to the remote destination.</span></div><div class="line">Udp.PacketSend();</div></div><!-- fragment --></li>
<li>To process a received UDP datagram. <div class="fragment"><div class="line"><span class="comment">// Save the newest UDP packet to be read from.</span></div><div class="line">uint16_t packetSize = Udp.PacketParse();</div><div class="line"><span class="comment">// Read the contents of the received packet into our own variable.</span></div><div class="line"><span class="keywordtype">char</span>[packetSize] packetContents;</div><div class="line">Udp.PacketRead(packetContents, packetSize);</div></div><!-- fragment --> </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
